<html>
    <head>
    </head>
    <body>

        <div style="float:left">
            <canvas id="board" width=500 height=500></canvas>
        </div>
        <div style="float:left">
            <label for="dimRg"><input id="dimRg" type="range" min="1" max="10" step="0.3" value="Scene.dim" oninput="Scene.changeDim(this.value)" onchange="Scene.changeDim(this.value)"/>Dim</label><br/>
            <label for="wireFrameCB"><input id="wireFrameCB" type="checkbox" onclick="Gui.handleCheckBox(this, Gui.WIREFRAME)" checked=true>Wire Frame</label><br/>
            <label for="surfaceCB"><input id="surfaceCB" type="checkbox" onclick="Gui.handleCheckBox(this, Gui.SURFACE)" checked=true>Surface</label><br/>
            <!-- TODO : <label for="textureCB"><input id="textureCB" type="checkbox" onclick="Gui.handleCheckBox(this, Gui.TEXTURE)" checked=false>Texture</label><br/> -->
            <label for="lightBulbCB"><input id="lightBulbCB" type="checkbox" onclick="Gui.handleCheckBox(this, Gui.LIGHTBULB)" checked=true>Light Bulb</label><br/>
        </div>
        <!--
        Vertex shader
        -->
        <script id="shader-vs" type="x-shader/x-vertex"> 
            precision highp float;
            attribute vec3 point;
            attribute vec3 rgb;
            attribute vec3 normal;
            attribute vec2 texCoord;

            uniform mat4 projectionMatrix;
            uniform mat4 modelViewMatrix;
            uniform mat3 normalMatrix;

            uniform vec3 lightPos;
            uniform vec4 lightSpecular;
            uniform vec4 lightAmbient;
            uniform vec4 lightDiffuse;

            uniform vec4 materialAmbient;
            uniform vec4 materialEmission;
            uniform vec4 materialSpecular;
            uniform vec4 materialDiffuse;
            uniform float materialShininess;

            vec4 phong()
            {
                //  P is the vertex coordinate on body
                vec3 P = vec3(modelViewMatrix * vec4(point,1.0));
                //  N is the object normal at P
                vec3 N = normalize(normalMatrix * normal);
                //  L is the light vector
                vec3 L = normalize(lightPos - P);

                //  Emission and ambient color
                vec4 color =  materialEmission + materialAmbient*lightAmbient ;

                //  Diffuse light intensity is cosine of light and normal vectors
                float Id = dot(L,N);
                if (Id>0.0)
                    {
                        //  Add diffuse
                        color += Id*lightDiffuse*materialDiffuse;
                        //  R is the reflected light vector R = 2(L.N)N - L
                        vec3 R = reflect(-L, N);
                        //  V is the view vector (eye at the origin)
                        vec3 V = normalize(-P);
                        //  Specular is cosine of reflected and view vectors
                        float Is = dot(R,V);
                        if (Is>0.0) color += pow(Is,materialShininess)*lightSpecular*materialSpecular;
                    }

                    //  Return sum of color components
                    return color;
            }
            varying vec4 fColor;
            varying vec2 fTexCoord;

            void main(void)
            {
                fColor = phong() + vec4(rgb, 1.0) ;
                fTexCoord = texCoord;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(point,1.0);
            }
        </script> 

        <!--
        Fragment shader
        -->
        <script id="shader-fs" type="x-shader/x-fragment"> 
            precision highp float;
            varying vec4 fColor;

            varying vec2 fTexCoord;
            uniform sampler2D uSampler;

            void main(void)
            {
                gl_FragColor = fColor + texture2D(uSampler, fTexCoord);
            }
        </script> 

        <script src="gl-matrix.js"></script>
        <script src="Scene.js"></script>
        <script src="Surface.js"></script>

        <script>
            // gui functions
        var Gui = {
            WIREFRAME : 1,
            SURFACE : 2,
            LIGHTBULB : 3,
            TEXTURE : 4,
            surfaceObj : undefined,
            wireFrameObj : undefined,
            lightBulbObj : undefined,
            init : function() {
                Scene.init("board", 10);
                var shader = Scene.addShaderProg("shader-vs","shader-fs");
                var tex = Scene.initTexture("chess.bmp");


                { // light Bulb
                    var bulbInfo = glUtils.sphere(0.2);
                    bulbInfo.shaderProgIdx = shader;

                    var tRgb = [];
                    for ( var i = 0 ; i < bulbInfo.points.length ; i++ ) {
                        tRgb[i] = [1,1,1];
                    }
                    bulbInfo.rgb = tRgb;

                    var lightBulbObj = Scene.createObject(bulbInfo);

                    var lBTrMatrix = lightBulbObj.transformationMatrix;
                    mat4.translate(lBTrMatrix, lBTrMatrix , Scene.light.position);

                    Scene.addObject(lightBulbObj);
                    Gui.lightBulbObj = lightBulbObj;
                }


                // surface equations
                var eqn = function (x,y) { 
                    return [ x, y , Math.pow(x,2)-Math.pow(y,2) ];
                }
                var grdnt = function(x,y,z) {
                    return [2*x, -2*y, -1];
                }
                var x0 = -2,
                x1 = 2,
                y0 = -2,
                y1 = 2,
                xParts = 10,
                yParts = 10;

                { // Surface
                    var surfaceInfo = Surface.createSurface(eqn, grdnt, x0, x1, y0, y1, xParts, yParts);
                    surfaceInfo.textureIdx = tex;
                    Gui.texIdStore = tex;
                    surfaceInfo.shaderProgIdx = shader;

                    Gui.surfaceObj = Scene.createObject(surfaceInfo);

                    Scene.addObject(Gui.surfaceObj);
                }

                { // wireFrame
                    var wireFrameInfo = Surface.createWireFrame(eqn,[0,0,0],x0, x1, y0, y1, xParts, yParts);
                    wireFrameInfo.shaderProgIdx = shader;
                    wireFrameInfo.drawMode = Scene.gl.LINES;
                    Gui.wireFrameObj = Scene.createObject(wireFrameInfo);

                    var trMtx = Gui.wireFrameObj.transformationMatrix;
                    mat4.translate(trMtx, trMtx, [0,0,0.003]);

                    Scene.addObject(Gui.wireFrameObj);
                }

                Scene.display();
                window.setTimeout(Scene.display, 50); // because textures don't load instantly !!
                window.setTimeout(Scene.display, 200); // just in case 50 ms is not enough
            },
            handleCheckBox : function(cb,id) {
                var procObj = function(obj) { 
                        if(cb.checked){
                            obj.show();
                        } else {
                            obj.hide();
                        }
                }
                switch(id) {
                    case Gui.SURFACE :
                        procObj(Gui.surfaceObj);
                        break;
                        Gui.lightBulbObj.show();
                    case Gui.WIREFRAME : 
                        procObj(Gui.wireFrameObj);
                        break;
                    case Gui.LIGHTBULB : 
                        procObj(Gui.lightBulbObj);
                        break;
                    case Gui.TEXTURE : 
                        if(cb.checked){
                            Gui.surfaceObj.textureIdx=Gui.texIdStore;
                        } else {
                            Gui.surfaceObj.textureIdx=-1;
                        }
                        break;
                }

                Scene.display();
            }
        }
        Gui.init();


        </script>
    </body>
</html>
